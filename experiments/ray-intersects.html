<!DOCTYPE html>
<html>
<head><title>Ray Intersection Test</title>
<style>
h3 {
  text-align: center;
}
</style>
<body>
<h3>ray intersection test</h3>
<canvas id="doodleArea" width="600" height="600" style="display: block; margin: 0 auto; border: 1px solid black;" />

<script>

var SegmentPoint = (x, y) => {
  return {
    x: x,
    y: y,
    n: undefined,
  };
};

class Map {

  constructor() {
    this._points = [];
    this._state = {
      isDrawing: false
    };
  }

  _less(a, b) {
    return (a < b ? a : b);
  }

  _greater(a, b) {
    return (a > b ? a : b);
  }

  _rayIntersects(ray, sp) {
    if (!sp.n) return;
    
    // find the slope and intercept of ray
    //var rayx = Math.cos(ray.a);
    //var rayy = Math.sin(ray.a);
    var rayx = ray.dx;
    var rayy = ray.dy;
    var rayM = undefined;
    var rayB = undefined;
    if (rayx !== ray.x) {
      rayM = (rayy - ray.y) / (rayx - ray.x);
      rayB = ray.y - rayM*ray.x;
    }

    // find slope and intercept of segment
    var segM = undefined;
    var segB = undefined;
    if (sp.x !== sp.n.x) {
      segM = (sp.n.y - sp.y) / (sp.n.x - sp.x);
      segB = sp.y - segM*sp.x;
    }

    // don't bother returning an intersection if slopes are the same
    if (rayM === segM) return;

    // the point at which the two instersect
    var p = {
      x: undefined,
      y: undefined
    };
    if (rayM === undefined) {
      p.x = ray.x;
      p.y = segM*p.x + segB;
    } else if (segM === undefined) {
      p.x = sp.x;
      p.y = rayM*p.x + rayB;
    } else {
      p.x = (rayB - segB)/(segM - rayM);
      p.y = rayM*p.x + rayB;
    }

    // check if point is on segment
    if (p.x < this._less(sp.x, sp.n.x) || p.x > this._greater(sp.x, sp.n.x)) return;
    else if (p.x === sp.x) {
      if (p.y < this._less(sp.y, sp.n.y) || p.y > this._greater(sp.y, sp.n.y)) return;
    }
    // and if point is in direction of ray
    if ((ray.x - p.x) * (ray.x - rayx) < 0) {
      return;
    } else if ((ray.x - p.x) * (ray.x - rayx) === 0) {
      if ((ray.y - p.y) * (ray.y - rayy) < 0) return;
    }

    return p;
  }

  addRectangle(x, y, dx, dy) {
    var topLeft = SegmentPoint(x, y);
    var topRight = SegmentPoint(x + dx, y);
    var bottomRight = SegmentPoint(x + dx, y + dy);
    var bottomLeft = SegmentPoint(x, y + dy);
    topLeft.n = topRight;
    topRight.n = bottomRight;
    bottomRight.n = bottomLeft;
    bottomLeft.n = topLeft;

    this._points.push(topLeft);
    this._points.push(topRight);
    this._points.push(bottomRight);
    this._points.push(bottomLeft);
  }

  addPoint(x, y) {
    var p = SegmentPoint(x, y);

    if (this._state.isDrawing) {
      if (this._points.length > 0) {
        this._points[this._points.length - 1].n = p;
      }
      this._state.isDrawing = false;
    } else {
      this._state.isDrawing = true;
    }

    this._points.push(p);
  }

  draw(context) {
    // draw ray
    context.save();
    context.strokeStyle = 'red';
    var rayLength = 30;
    var norm = Math.sqrt(Math.pow(mouse.x-300, 2) + Math.pow(mouse.y-300, 2));
    var x_norm = (mouse.x-300)/norm;
    var y_norm = (mouse.y-300)/norm;
    context.beginPath();
    context.moveTo(300, 300);
    context.lineTo(300 + x_norm*rayLength, 300 + y_norm*rayLength);
    context.stroke();
    context.restore();

    // draw line segments
    context.beginPath();
    this._points.forEach((point) => {
      context.moveTo(point.x, point.y);
      if (point.n) {
        context.lineTo(point.n.x, point.n.y);
      }
    });
    context.stroke();

    var intersections = [];

    for (var i = 0; i < this._points.length; i++) {
      var test = this._rayIntersects({
        x: 300,
        y: 300,
        dx: mouse.x,
        dy: mouse.y
      }, this._points[i]);

      if (test) {
        intersections.push(test);
        //context.translate(test.x, test.y);
        //context.beginPath();
        //context.arc(0, 0, 4, 0, Math.PI*2);
        //context.stroke();
        //context.setTransform(1, 0, 0, 1, 0, 0);
      }
    }

    intersections.sort((a, b) => {
      return Math.sqrt(Math.pow(a.x - 300, 2) + Math.pow(a.y - 300, 2)) -
        Math.sqrt(Math.pow(b.x - 300, 2) + Math.pow(b.y - 300, 2));
    });

    if (intersections.length > 0) {
      context.translate(intersections[0].x, intersections[0].y);
      context.beginPath();
      context.arc(0, 0, 4, 0, Math.PI*2);
      context.stroke();
      context.setTransform(1, 0, 0, 1, 0, 0);
    }

    if (this._state.isDrawing) {
      var p = this._points[this._points.length - 1];
      context.beginPath();
      context.moveTo(p.x, p.y);
      context.lineTo(mouse.x, mouse.y);
      context.stroke();
    }
  }

}

var mouse = {
  x: undefined,
  y: undefined
};

var state = {
  update: false
};

function setup() {
  var canvas = document.getElementById('doodleArea');
  var context = canvas.getContext('2d');
  var map = new Map();
  map.addRectangle(50, 50, canvas.width - 100, canvas.height - 100);

  window.map = map;

  var draw = () => {
    context.clearRect(0, 0, canvas.width, canvas.height);
    context.translate(mouse.x, mouse.y);
    context.beginPath();
    context.moveTo(-5, 0);
    context.lineTo(5, 0);
    context.moveTo(0, -5);
    context.lineTo(0, 5);
    context.stroke();
    context.setTransform(1, 0, 0, 1, 0, 0);

    map.draw(context);
  };

  canvas.addEventListener('mousemove', (e) => {
    mouse.x = e.offsetX;
    mouse.y = e.offsetY;
    state.update = true;
  });

  canvas.addEventListener('click', (e) => {
    map.addPoint(mouse.x, mouse.y);
    state.update = true;
  });

  window.setInterval(() => {
    if (state.update) {
      window.requestAnimationFrame(draw);
      state.update = false;
    }
  }, 20);

  state.update = true;
}

setup();

</script>

</body>
</html>
